<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Oxbox Games</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <!-- favicon -->
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="manifest" href="/site.webmanifest" />
  <!-- end of favicon -->

  <!-- SEO stuff -->
  <meta name="description" content="Oxbox Games is an indie game studio creating experimental games. Follow development updates and upcoming releases." />
  <meta name="robots" content="index, follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- SEO Open Graph -->
  <meta property="og:title" content="Oxbox Games" />
  <meta property="og:description" content="Indie game studio creating experimental games." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://www.oxboxgames.com" />
  <!-- end of SEO -->

  <style>
    body {
      margin: 0;
      height: 100vh;
      background: #0f0f0f;
      color: #eaeaea;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    .container {
      max-width: 600px;
      padding: 2rem;
    }

    img {
      display: block;
      width: 320px;
      max-width: 80%;
      margin: 0 auto 1.5rem auto;
      transition: transform 0.3s ease, filter 0.3s ease;
      cursor: pointer;
    }

    img:hover {
      transform: scale(1.08);
      filter: brightness(1.2) drop-shadow(0 0 20px rgba(255, 255, 255, 0.5));
    }

    .sparkle {
      position: fixed;
      pointer-events: none;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, transparent 70%);
      animation: sparkle-fade 0.8s ease-out forwards;
      z-index: 9999;
    }

    @keyframes sparkle-fade {
      0% {
        opacity: 1;
        transform: scale(1) rotate(0deg);
      }
      100% {
        opacity: 0;
        transform: scale(0) rotate(180deg);
      }
    }

    h1 {
      margin: 0.5rem 0;
      font-size: 2.6rem;
      letter-spacing: 0.05em;
      font-weight: 900;
      background: linear-gradient(180deg, #f5f5f5 0%, #a0a0a0 50%, #f5f5f5 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: none;
      filter: drop-shadow(2px 2px 1px rgba(0,0,0,0.5));
      transition: all 0.3s ease;
      cursor: default;
    }

    h1 span.ox {
      background: linear-gradient(180deg, #f5f5f5 0%, #a0a0a0 50%, #f5f5f5 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    h1 span.box {
      background: linear-gradient(180deg, #ffa500 0%, #ff6600 50%, #ffa500 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    h1 span.games {
      display: block;
      font-size: 1.2rem;
      letter-spacing: 0.3em;
      background: linear-gradient(180deg, #ffd700 0%, #ff8c00 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-top: -0.3rem;
    }

    h1:hover span.ox,
    h1:hover span.box,
    h1:hover span.games {
      -webkit-text-fill-color: transparent;
      background: linear-gradient(180deg, #ff4444 0%, #ff0000 50%, #ff4444 100%);
      -webkit-background-clip: text;
      background-clip: text;
      filter: drop-shadow(0 0 10px #ff0000) drop-shadow(0 0 20px #ff0000);
    }

    p {
      opacity: 0.75;
      line-height: 1.6;
      font-size: 1.1rem;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    #bull-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    .container {
      position: relative;
      z-index: 10;
    }
  </style>
</head>
<body>
  <canvas id="bull-canvas"></canvas>
  <div class="container">
    <img src="oxbox_games_logo.png" alt="Oxbox Games logo">
    <h1 id="title"><span class="ox">OX</span><span class="box">BOX</span><span class="games">GAMES</span></h1>
    <p>
      Independent game studio.<br>
      Focused on tight gameplay, strong systems,
      and player-respecting design.
    </p>
  </div>

  <script>
    const colors = ['#fff', '#ffd700', '#ff69b4', '#00ffff', '#ff6b6b', '#98fb98'];
    let lastSparkle = 0;
    const sparkleInterval = 50;

    document.addEventListener('mousemove', (e) => {
      const now = Date.now();
      if (now - lastSparkle < sparkleInterval) return;
      lastSparkle = now;

      for (let i = 0; i < 3; i++) {
        setTimeout(() => createSparkle(e.clientX, e.clientY), i * 30);
      }
    });

    function createSparkle(x, y) {
      const sparkle = document.createElement('div');
      sparkle.className = 'sparkle';

      const offsetX = (Math.random() - 0.5) * 30;
      const offsetY = (Math.random() - 0.5) * 30;
      const size = Math.random() * 8 + 4;
      const color = colors[Math.floor(Math.random() * colors.length)];

      sparkle.style.left = (x + offsetX) + 'px';
      sparkle.style.top = (y + offsetY) + 'px';
      sparkle.style.width = size + 'px';
      sparkle.style.height = size + 'px';
      sparkle.style.background = `radial-gradient(circle, ${color} 0%, transparent 70%)`;
      sparkle.style.boxShadow = `0 0 ${size}px ${color}`;

      document.body.appendChild(sparkle);

      setTimeout(() => sparkle.remove(), 800);
    }
  </script>

  <script>
    // 3D Bulls running around perimeter
    const canvas = document.getElementById('bull-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7);
    scene.add(directionalLight);

    // Bull colors matching logo
    const bodyColor = 0x8B4513;
    const hornColor = 0xFFFACD;
    const darkColor = 0x4a2106;

    // Audio context for grunt sounds
    let audioCtx = null;
    function playGrunt() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.setValueAtTime(80, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.15);
      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
      osc.type = 'sawtooth';
      osc.start();
      osc.stop(audioCtx.currentTime + 0.2);
    }

    // Leg references for animation
    function createBull() {
      const bull = new THREE.Group();
      const legs = [];

      const bodyMat = new THREE.MeshPhongMaterial({ color: bodyColor, shininess: 30 });
      const furMat = new THREE.MeshPhongMaterial({ color: 0x654321, shininess: 10 });
      const snoutMat = new THREE.MeshPhongMaterial({ color: 0xD2691E, shininess: 20 });
      const hornMat = new THREE.MeshPhongMaterial({ color: hornColor, shininess: 60 });
      const legMat = new THREE.MeshPhongMaterial({ color: darkColor, shininess: 20 });
      const eyeMat = new THREE.MeshPhongMaterial({ color: 0x220000, shininess: 100 });
      const noseMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a, shininess: 50 });

      // Body - elongated sphere
      const bodyGeo = new THREE.SphereGeometry(1, 16, 12);
      bodyGeo.scale(1.4, 0.8, 0.7);
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      bull.add(body);

      // Chest/shoulder hump
      const chestGeo = new THREE.SphereGeometry(0.6, 12, 10);
      const chest = new THREE.Mesh(chestGeo, bodyMat);
      chest.position.set(0.5, 0.4, 0);
      chest.scale.set(1, 1.1, 0.9);
      bull.add(chest);

      // Fur/mane around neck
      const maneGeo = new THREE.SphereGeometry(0.5, 10, 8);
      const mane = new THREE.Mesh(maneGeo, furMat);
      mane.position.set(0.9, 0.2, 0);
      mane.scale.set(0.8, 1, 1.2);
      bull.add(mane);

      // Head - sphere
      const headGeo = new THREE.SphereGeometry(0.5, 14, 12);
      const head = new THREE.Mesh(headGeo, bodyMat);
      head.position.set(1.3, 0.35, 0);
      head.scale.set(1, 0.9, 0.85);
      bull.add(head);

      // Snout - elongated sphere
      const snoutGeo = new THREE.SphereGeometry(0.3, 12, 10);
      snoutGeo.scale(1.2, 0.8, 1);
      const snout = new THREE.Mesh(snoutGeo, snoutMat);
      snout.position.set(1.7, 0.15, 0);
      bull.add(snout);

      // Nostrils
      const nostrilGeo = new THREE.SphereGeometry(0.06, 8, 6);
      [-0.1, 0.1].forEach(z => {
        const nostril = new THREE.Mesh(nostrilGeo, noseMat);
        nostril.position.set(1.95, 0.1, z);
        bull.add(nostril);
      });

      // Eyes
      const eyeGeo = new THREE.SphereGeometry(0.08, 10, 8);
      const eyeWhiteGeo = new THREE.SphereGeometry(0.12, 10, 8);
      const eyeWhiteMat = new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 100 });
      [-0.25, 0.25].forEach(z => {
        const eyeWhite = new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat);
        eyeWhite.position.set(1.5, 0.5, z);
        bull.add(eyeWhite);
        const eye = new THREE.Mesh(eyeGeo, eyeMat);
        eye.position.set(1.58, 0.5, z);
        bull.add(eye);
      });

      // Ears
      const earGeo = new THREE.ConeGeometry(0.15, 0.25, 8);
      [-0.35, 0.35].forEach(z => {
        const ear = new THREE.Mesh(earGeo, bodyMat);
        ear.position.set(1.1, 0.7, z);
        ear.rotation.x = z > 0 ? -0.5 : 0.5;
        ear.rotation.z = -0.3;
        bull.add(ear);
      });

      // Horns - curved using torus segments
      const hornGeo = new THREE.ConeGeometry(0.1, 0.8, 12);

      const leftHorn = new THREE.Mesh(hornGeo, hornMat);
      leftHorn.position.set(1.15, 0.85, 0.3);
      leftHorn.rotation.z = -0.6;
      leftHorn.rotation.x = -0.4;
      bull.add(leftHorn);

      const rightHorn = new THREE.Mesh(hornGeo, hornMat);
      rightHorn.position.set(1.15, 0.85, -0.3);
      rightHorn.rotation.z = -0.6;
      rightHorn.rotation.x = 0.4;
      bull.add(rightHorn);

      // Horn tips
      const tipGeo = new THREE.SphereGeometry(0.06, 8, 6);
      const tipMat = new THREE.MeshPhongMaterial({ color: 0xfffff0, shininess: 80 });
      const leftTip = new THREE.Mesh(tipGeo, tipMat);
      leftTip.position.set(0.85, 1.2, 0.5);
      bull.add(leftTip);
      const rightTip = new THREE.Mesh(tipGeo, tipMat);
      rightTip.position.set(0.85, 1.2, -0.5);
      bull.add(rightTip);

      // Legs - cylinders with joints
      const upperLegGeo = new THREE.CylinderGeometry(0.12, 0.1, 0.5, 10);
      const lowerLegGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.45, 10);
      const hoofGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.12, 10);
      const hoofMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a, shininess: 40 });

      const legPositions = [
        { x: 0.7, z: 0.3, phase: 0 },
        { x: 0.7, z: -0.3, phase: Math.PI },
        { x: -0.8, z: 0.3, phase: Math.PI },
        { x: -0.8, z: -0.3, phase: 0 }
      ];

      legPositions.forEach(pos => {
        const legPivot = new THREE.Group();
        legPivot.position.set(pos.x, -0.4, pos.z);

        const upperLeg = new THREE.Mesh(upperLegGeo, legMat);
        upperLeg.position.y = -0.25;
        legPivot.add(upperLeg);

        const lowerLeg = new THREE.Mesh(lowerLegGeo, legMat);
        lowerLeg.position.y = -0.55;
        legPivot.add(lowerLeg);

        const hoof = new THREE.Mesh(hoofGeo, hoofMat);
        hoof.position.y = -0.8;
        legPivot.add(hoof);

        legPivot.userData.phase = pos.phase;
        bull.add(legPivot);
        legs.push(legPivot);
      });

      // Tail - multiple segments
      const tailGroup = new THREE.Group();
      tailGroup.position.set(-1.3, 0.1, 0);
      for (let i = 0; i < 4; i++) {
        const segGeo = new THREE.CylinderGeometry(0.04 - i*0.008, 0.04 - (i+1)*0.008, 0.25, 8);
        const seg = new THREE.Mesh(segGeo, legMat);
        seg.position.set(-i * 0.2, -i * 0.1, 0);
        seg.rotation.z = 0.3 + i * 0.15;
        tailGroup.add(seg);
      }
      // Tail tuft
      const tuftGeo = new THREE.SphereGeometry(0.08, 8, 6);
      const tuft = new THREE.Mesh(tuftGeo, furMat);
      tuft.position.set(-0.7, -0.4, 0);
      tailGroup.add(tuft);
      bull.add(tailGroup);

      // Nose ring
      const ringGeo = new THREE.TorusGeometry(0.1, 0.025, 12, 20);
      const ringMat = new THREE.MeshPhongMaterial({ color: 0xC0C0C0, shininess: 100 });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.set(1.92, 0.02, 0);
      ring.rotation.y = Math.PI / 2;
      bull.add(ring);

      bull.scale.set(0.8, 0.8, 0.8);
      bull.userData.legs = legs;

      return bull;
    }

    // Create animated box (like in logo)
    function createBox() {
      const box = new THREE.Group();
      const flaps = [];

      const boxMat = new THREE.MeshPhongMaterial({ color: 0xD2691E, shininess: 30 });
      const boxLightMat = new THREE.MeshPhongMaterial({ color: 0xE8A030, shininess: 40 });
      const boxDarkMat = new THREE.MeshPhongMaterial({ color: 0xA0522D, shininess: 20 });
      const insideMat = new THREE.MeshPhongMaterial({ color: 0x8B4513, shininess: 10 });

      // Box base (bottom)
      const baseGeo = new THREE.BoxGeometry(1, 0.1, 1);
      const base = new THREE.Mesh(baseGeo, boxDarkMat);
      base.position.y = -0.45;
      box.add(base);

      // Box sides
      const sideGeo = new THREE.BoxGeometry(1, 0.8, 0.08);
      const frontSide = new THREE.Mesh(sideGeo, boxMat);
      frontSide.position.set(0, 0, 0.46);
      box.add(frontSide);

      const backSide = new THREE.Mesh(sideGeo, boxMat);
      backSide.position.set(0, 0, -0.46);
      box.add(backSide);

      const sideSideGeo = new THREE.BoxGeometry(0.08, 0.8, 1);
      const leftSide = new THREE.Mesh(sideSideGeo, boxLightMat);
      leftSide.position.set(-0.46, 0, 0);
      box.add(leftSide);

      const rightSide = new THREE.Mesh(sideSideGeo, boxDarkMat);
      rightSide.position.set(0.46, 0, 0);
      box.add(rightSide);

      // Inside darkness
      const insideGeo = new THREE.BoxGeometry(0.9, 0.7, 0.9);
      const inside = new THREE.Mesh(insideGeo, insideMat);
      inside.position.y = -0.05;
      box.add(inside);

      // Flaps (animated)
      const flapGeo = new THREE.BoxGeometry(0.9, 0.08, 0.4);
      const flapSideGeo = new THREE.BoxGeometry(0.4, 0.08, 0.9);

      // Front flap
      const frontFlapPivot = new THREE.Group();
      frontFlapPivot.position.set(0, 0.4, 0.46);
      const frontFlap = new THREE.Mesh(flapGeo, boxLightMat);
      frontFlap.position.z = 0.2;
      frontFlapPivot.add(frontFlap);
      box.add(frontFlapPivot);
      flaps.push({ pivot: frontFlapPivot, axis: 'x', dir: 1 });

      // Back flap
      const backFlapPivot = new THREE.Group();
      backFlapPivot.position.set(0, 0.4, -0.46);
      const backFlap = new THREE.Mesh(flapGeo, boxLightMat);
      backFlap.position.z = -0.2;
      backFlapPivot.add(backFlap);
      box.add(backFlapPivot);
      flaps.push({ pivot: backFlapPivot, axis: 'x', dir: -1 });

      // Left flap
      const leftFlapPivot = new THREE.Group();
      leftFlapPivot.position.set(-0.46, 0.4, 0);
      const leftFlap = new THREE.Mesh(flapSideGeo, boxMat);
      leftFlap.position.x = -0.2;
      leftFlapPivot.add(leftFlap);
      box.add(leftFlapPivot);
      flaps.push({ pivot: leftFlapPivot, axis: 'z', dir: -1 });

      // Right flap
      const rightFlapPivot = new THREE.Group();
      rightFlapPivot.position.set(0.46, 0.4, 0);
      const rightFlap = new THREE.Mesh(flapSideGeo, boxMat);
      rightFlap.position.x = 0.2;
      rightFlapPivot.add(rightFlap);
      box.add(rightFlapPivot);
      flaps.push({ pivot: rightFlapPivot, axis: 'z', dir: 1 });

      box.scale.set(0.6, 0.6, 0.6);
      box.userData.flaps = flaps;
      return box;
    }

    // Create 20 bulls with perimeter path data
    const bulls = [];
    const numBulls = 20;
    const margin = 3;

    for (let i = 0; i < numBulls; i++) {
      const bull = createBull();
      bull.userData = {
        ...bull.userData,
        progress: i / numBulls,
        speed: 0.0003 + Math.random() * 0.0002,
        bobOffset: Math.random() * Math.PI * 2,
        targetX: 0,
        targetY: 0,
        chasing: false,
        facingRight: true,
        lastGrunt: 0
      };
      scene.add(bull);
      bulls.push(bull);
    }

    // Create floating boxes
    const boxes = [];
    const numBoxes = 8;

    for (let i = 0; i < numBoxes; i++) {
      const box = createBox();
      box.userData = {
        flaps: box.userData.flaps,
        floatOffset: Math.random() * Math.PI * 2,
        floatSpeed: 0.5 + Math.random() * 0.5,
        rotSpeed: 0.2 + Math.random() * 0.3,
        openPhase: Math.random() * Math.PI * 2,
        openSpeed: 0.3 + Math.random() * 0.2,
        x: (Math.random() - 0.5) * 30,
        y: (Math.random() - 0.5) * 20,
        driftX: (Math.random() - 0.5) * 0.01,
        driftY: (Math.random() - 0.5) * 0.01
      };
      box.position.set(box.userData.x, box.userData.y, -5);
      scene.add(box);
      boxes.push(box);
    }

    // Mouse tracking
    let mouseX = 0, mouseY = 0;
    let isHoveringTitle = false;

    const title = document.getElementById('title');
    title.addEventListener('mouseenter', () => { isHoveringTitle = true; });
    title.addEventListener('mouseleave', () => { isHoveringTitle = false; });

    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    function screenToWorld(sx, sy) {
      const aspect = window.innerWidth / window.innerHeight;
      const vFov = camera.fov * Math.PI / 180;
      const height = 2 * Math.tan(vFov / 2) * camera.position.z;
      const width = height * aspect;
      return {
        x: (sx / window.innerWidth - 0.5) * width,
        y: -(sy / window.innerHeight - 0.5) * height
      };
    }

    function getPerimeterPosition(progress, w, h) {
      const perimeter = 2 * w + 2 * h;
      const dist = progress * perimeter;

      if (dist < w) {
        return { x: -w/2 + dist, y: h/2, dir: 1 };
      } else if (dist < w + h) {
        return { x: w/2, y: h/2 - (dist - w), dir: 1 };
      } else if (dist < 2*w + h) {
        return { x: w/2 - (dist - w - h), y: -h/2, dir: -1 };
      } else {
        return { x: -w/2, y: -h/2 + (dist - 2*w - h), dir: -1 };
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      const aspect = window.innerWidth / window.innerHeight;
      const vFov = camera.fov * Math.PI / 180;
      const height = 2 * Math.tan(vFov / 2) * camera.position.z;
      const width = height * aspect;
      const time = Date.now() * 0.001;

      const mouseWorld = screenToWorld(mouseX, mouseY);

      bulls.forEach(bull => {
        const ud = bull.userData;
        let targetX, targetY, movingRight;

        if (isHoveringTitle) {
          // Chase mouse
          targetX = mouseWorld.x;
          targetY = mouseWorld.y;
          ud.chasing = true;
        } else {
          // Return to perimeter
          ud.progress += ud.speed;
          if (ud.progress > 1) ud.progress -= 1;
          const pos = getPerimeterPosition(ud.progress, width - margin * 2, height - margin * 2);
          targetX = pos.x;
          targetY = pos.y;
          movingRight = pos.dir > 0;
          ud.chasing = false;
        }

        // Smooth movement toward target
        const dx = targetX - bull.position.x;
        const dy = targetY - bull.position.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const moveSpeed = ud.chasing ? 0.015 : 0.08;

        bull.position.x += dx * moveSpeed;
        bull.position.y += dy * moveSpeed;

        // Determine facing direction based on horizontal movement
        if (Math.abs(dx) > 0.01) {
          ud.facingRight = dx > 0;
        }

        // Flip bull horizontally using scale (keeps side view always facing camera)
        // Bull is built along X axis, so we flip scale.x to change direction
        const targetScaleX = ud.facingRight ? 0.8 : -0.8;
        bull.scale.x += (targetScaleX - bull.scale.x) * 0.15;

        // Keep rotation.y at 0 so side always faces camera
        bull.rotation.y = 0;

        // Leg animation - galloping motion
        const legSpeed = ud.chasing ? 15 : 8;
        const legAmplitude = ud.chasing ? 0.6 : 0.3;
        ud.legs.forEach(leg => {
          leg.rotation.x = Math.sin(time * legSpeed + leg.userData.phase + ud.bobOffset) * legAmplitude;
        });

        // Body bob
        bull.position.y += Math.sin(time * (ud.chasing ? 12 : 6) + ud.bobOffset) * (ud.chasing ? 0.1 : 0.05);

        // Check if reached mouse (grunt)
        if (ud.chasing && dist < 2) {
          const now = Date.now();
          if (now - ud.lastGrunt > 500) {
            playGrunt();
            ud.lastGrunt = now;
          }
        }
      });

      // Animate boxes
      boxes.forEach(box => {
        const ud = box.userData;

        // Float and drift
        ud.x += ud.driftX;
        ud.y += ud.driftY;

        // Wrap around screen
        const halfW = width / 2;
        const halfH = height / 2;
        if (ud.x > halfW) ud.x = -halfW;
        if (ud.x < -halfW) ud.x = halfW;
        if (ud.y > halfH) ud.y = -halfH;
        if (ud.y < -halfH) ud.y = halfH;

        box.position.x = ud.x;
        box.position.y = ud.y + Math.sin(time * ud.floatSpeed + ud.floatOffset) * 0.5;

        // Rotate slowly
        box.rotation.y += ud.rotSpeed * 0.01;
        box.rotation.x = Math.sin(time * 0.3 + ud.floatOffset) * 0.1;

        // Animate flaps open/closed
        const openAmount = (Math.sin(time * ud.openSpeed + ud.openPhase) + 1) / 2; // 0 to 1
        const flapAngle = openAmount * Math.PI * 0.4; // 0 to ~72 degrees

        ud.flaps.forEach(flap => {
          if (flap.axis === 'x') {
            flap.pivot.rotation.x = flapAngle * flap.dir;
          } else {
            flap.pivot.rotation.z = flapAngle * flap.dir;
          }
        });
      });

      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
