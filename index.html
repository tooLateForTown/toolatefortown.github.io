<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Oxbox Games</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <!-- favicon -->
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="manifest" href="/site.webmanifest" />
  <!-- end of favicon -->

  <!-- SEO stuff -->
  <meta name="description" content="Oxbox Games is an indie game studio creating experimental games. Follow development updates and upcoming releases." />
  <meta name="robots" content="index, follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- SEO Open Graph -->
  <meta property="og:title" content="Oxbox Games" />
  <meta property="og:description" content="Indie game studio creating experimental games." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://www.oxboxgames.com" />
  <!-- end of SEO -->

  <style>
    body {
      margin: 0;
      height: 100vh;
      background: #0f0f0f;
      color: #eaeaea;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    .container {
      max-width: 600px;
      padding: 2rem;
    }

    img {
      display: block;
      width: 320px;
      max-width: 80%;
      margin: 0 auto 1.5rem auto;
      transition: transform 0.3s ease, filter 0.3s ease;
      cursor: pointer;
    }

    img:hover {
      transform: scale(1.08);
      filter: brightness(1.2) drop-shadow(0 0 20px rgba(255, 255, 255, 0.5));
    }

    .sparkle {
      position: fixed;
      pointer-events: none;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, transparent 70%);
      animation: sparkle-fade 0.8s ease-out forwards;
      z-index: 9999;
    }

    @keyframes sparkle-fade {
      0% {
        opacity: 1;
        transform: scale(1) rotate(0deg);
      }
      100% {
        opacity: 0;
        transform: scale(0) rotate(180deg);
      }
    }

    h1 {
      margin: 0.5rem 0;
      font-size: 2.6rem;
      letter-spacing: 0.05em;
      font-weight: 900;
      background: linear-gradient(180deg, #f5f5f5 0%, #a0a0a0 50%, #f5f5f5 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: none;
      filter: drop-shadow(2px 2px 1px rgba(0,0,0,0.5));
      transition: all 0.3s ease;
      cursor: default;
    }

    h1 span.ox {
      background: linear-gradient(180deg, #f5f5f5 0%, #a0a0a0 50%, #f5f5f5 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    h1 span.box {
      background: linear-gradient(180deg, #ffa500 0%, #ff6600 50%, #ffa500 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    h1 span.games {
      display: block;
      font-size: 1.2rem;
      letter-spacing: 0.3em;
      background: linear-gradient(180deg, #ffd700 0%, #ff8c00 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-top: -0.3rem;
    }

    h1:hover span.ox,
    h1:hover span.box,
    h1:hover span.games {
      -webkit-text-fill-color: transparent;
      background: linear-gradient(180deg, #ff4444 0%, #ff0000 50%, #ff4444 100%);
      -webkit-background-clip: text;
      background-clip: text;
      filter: drop-shadow(0 0 10px #ff0000) drop-shadow(0 0 20px #ff0000);
    }

    p {
      opacity: 0.75;
      line-height: 1.6;
      font-size: 1.1rem;
    }

    .games-sections {
      margin-top: 2rem;
      padding-top: 1.5rem;
      border-top: 1px solid rgba(255,255,255,0.1);
      display: flex;
      gap: 2rem;
      justify-content: center;
      flex-wrap: wrap;
    }

    .games-section {
      flex: 1;
      min-width: 250px;
      max-width: 300px;
    }

    .games-section h2 {
      font-size: 0.9rem;
      opacity: 0.5;
      margin-bottom: 0.8rem;
      font-weight: normal;
      letter-spacing: 0.05em;
    }

    .game-quote {
      min-height: 3.5em;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .game-quote.visible {
      opacity: 1;
    }

    .game-quote .game-name {
      color: #ffa500;
      font-weight: bold;
      font-size: 1.1rem;
    }

    .game-quote .reason, .game-quote .excuse {
      opacity: 0.7;
      font-style: italic;
      font-size: 0.95rem;
    }

    .game-quote .excuse {
      color: #88ccff;
    }

    .made-by .status {
      color: #666;
      font-size: 0.85rem;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    #bull-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    .container {
      position: relative;
      z-index: 10;
    }
  </style>
</head>
<body>
  <canvas id="bull-canvas"></canvas>
  <div class="container">
    <img src="oxbox_games_logo.png" alt="Oxbox Games logo">
    <h1 id="title"><span class="ox">OX</span><span class="box">BOX</span><span class="games">GAMES</span></h1>
    <p>
      Independent game studio.<br>
      Focused on tight gameplay, strong systems,
      and player-respecting design.
    </p>
    <div class="games-sections">
      <div class="games-section made-by">
        <h2>Games made by Oxbox Games:</h2>
        <div class="game-quote" id="game-quote-made">
          <span class="status">None yet...</span><br>
          <span class="excuse"></span>
        </div>
      </div>
      <div class="games-section not-made-by">
        <h2>Games NOT made by Oxbox Games:</h2>
        <div class="game-quote" id="game-quote-not">
          <span class="game-name"></span><br>
          <span class="reason"></span>
        </div>
      </div>
    </div>
  </div>

  <script>
    const colors = ['#fff', '#ffd700', '#ff69b4', '#00ffff', '#ff6b6b', '#98fb98'];
    let lastSparkle = 0;
    const sparkleInterval = 50;

    document.addEventListener('mousemove', (e) => {
      const now = Date.now();
      if (now - lastSparkle < sparkleInterval) return;
      lastSparkle = now;

      for (let i = 0; i < 3; i++) {
        setTimeout(() => createSparkle(e.clientX, e.clientY), i * 30);
      }
    });

    function createSparkle(x, y) {
      const sparkle = document.createElement('div');
      sparkle.className = 'sparkle';

      const offsetX = (Math.random() - 0.5) * 30;
      const offsetY = (Math.random() - 0.5) * 30;
      const size = Math.random() * 8 + 4;
      const color = colors[Math.floor(Math.random() * colors.length)];

      sparkle.style.left = (x + offsetX) + 'px';
      sparkle.style.top = (y + offsetY) + 'px';
      sparkle.style.width = size + 'px';
      sparkle.style.height = size + 'px';
      sparkle.style.background = `radial-gradient(circle, ${color} 0%, transparent 70%)`;
      sparkle.style.boxShadow = `0 0 ${size}px ${color}`;

      document.body.appendChild(sparkle);

      setTimeout(() => sparkle.remove(), 800);
    }

    // Games NOT made by Oxbox Games
    const gamesNotMade = [
      ["Hollow Knight", "Art and music way too fancy for our stick figures"],
      ["The Last of Us", "Voice actors expect actual paychecks"],
      ["Red Dead Redemption 2", "Horse physics alone would bankrupt us"],
      ["GTA V", "Our legal team is just a guy named Steve who took one law class"],
      ["Elden Ring", "FromSoftware has more employees than we have chairs"],
      ["Minecraft", "We can't even make cubes look that good"],
      ["The Witcher 3", "Geralt's hair physics cost more than our entire office"],
      ["God of War", "Kratos's beard has more polygons than our whole game"],
      ["Zelda: Breath of the Wild", "We can't afford that much grass"],
      ["Cyberpunk 2077", "Even with bugs, it's prettier than our best work"],
      ["Skyrim", "Todd Howard has more re-releases than we have releases"],
      ["Dark Souls", "Our QA tester rage-quit on level one"],
      ["Portal", "We failed the physics exam. Twice."],
      ["Half-Life 2", "Valve can count to 2, we're still learning"],
      ["Halo", "Master Chief's helmet costs more than our budget"],
      ["Super Mario Odyssey", "Nintendo's legal team haunts our dreams"],
      ["DOOM", "Our computers can't even run it, let alone make it"],
      ["Tetris", "We couldn't figure out how to rotate blocks"],
      ["Pac-Man", "Yellow circles are surprisingly difficult"],
      ["Sonic the Hedgehog", "Too fast, our game engine just crashes"],
      ["Final Fantasy VII", "Seven is a lot of fantasies to keep track of"],
      ["Metal Gear Solid", "We can't afford cardboard boxes... wait"],
      ["Resident Evil", "Our zombies look like tired interns"],
      ["Street Fighter", "We only know how to throw weak punches"],
      ["Mortal Kombat", "Fatalities require actual animation skills"],
      ["Assassin's Creed", "Parkour is hard, climbing ladders is our limit"],
      ["Bioshock", "Would you kindly fund our tiny studio?"],
      ["Mass Effect", "Our dialogue wheel has one option: 'OK'"],
      ["Dragon Age", "We can't draw dragons, only angry lizards"],
      ["Fallout", "Our post-apocalypse looks like a messy bedroom"],
      ["Borderlands", "We ran out of cel-shading budget on day one"],
      ["Diablo", "Our demons look like angry potatoes"],
      ["World of Warcraft", "We can't even organize a team lunch"],
      ["League of Legends", "Our toxicity budget is way too low"],
      ["Overwatch", "Our characters would all look suspiciously similar"],
      ["Fortnite", "Building mechanics require geometry knowledge"],
      ["PUBG", "100 players? We can barely handle 2"],
      ["Among Us", "Our impostor is way too obvious"],
      ["Stardew Valley", "One guy made this masterpiece. We need twelve."],
      ["Undertale", "Toby Fox has more talent in his dog than our whole team"],
      ["Cuphead", "Hand-drawn animation? We have MS Paint"],
      ["Celeste", "We can't climb that many mountains emotionally"],
      ["Hades", "Greek mythology requires reading actual books"],
      ["Shovel Knight", "We literally cannot afford a shovel"],
      ["Dead Cells", "Our cells are very much alive and extremely lazy"],
      ["Ori and the Blind Forest", "Our forest spirits look like blurry smudges"],
      ["Limbo", "Our shadows aren't that artistic or meaningful"],
      ["Inside", "We're still outside trying to get in the industry"],
      ["Braid", "Time manipulation is beyond our skill tree"],
      ["Super Meat Boy", "Our meat is tragically undercooked"],
      ["Spelunky", "We're genuinely afraid of caves"],
      ["The Binding of Isaac", "Too many tears, not enough tissues"],
      ["Enter the Gungeon", "We only have one gun emoji to work with"],
      ["Slay the Spire", "We can't even climb regular stairs"],
      ["Inscryption", "We don't understand card games or horror"],
      ["Disco Elysium", "Our dialogue trees are just sad stumps"],
      ["Divinity: Original Sin 2", "Turn-based combat requires patience we lack"],
      ["Baldur's Gate 3", "Larian has more voice lines than we have code"],
      ["Uncharted", "Our treasure hunting only finds bugs"],
      ["Spider-Man", "Web physics are way too sticky for us"],
      ["Batman: Arkham Asylum", "We can't afford the Batmobile insurance"],
      ["Sekiro", "We died just reading the tutorial description"],
      ["Bloodborne", "Our blood effects are just ketchup splats"],
      ["Demon's Souls", "Too many souls, not enough programming bodies"],
      ["Ghost of Tsushima", "Wind effects are a premium feature apparently"],
      ["Horizon Zero Dawn", "Robot dinosaurs need actual engineering degrees"],
      ["Death Stranding", "We don't understand it either, honestly"],
      ["Control", "Our furniture stubbornly stays on the ground"],
      ["Alan Wake", "We're genuinely afraid of the dark"],
      ["Titanfall", "Our titans fall down and refuse to get up"],
      ["Apex Legends", "Battle royale needs more than 3 players and a dream"],
      ["Destiny", "Our loot drops are just mismatched socks"],
      ["The Division", "We can't divide, only subtract from our budget"],
      ["Watch Dogs", "Hacking requires computers newer than 2005"],
      ["Far Cry", "Our cry is more of a gentle whimper"],
      ["Just Cause", "Our explosions are basically sparklers"],
      ["Saints Row", "Our saints are unfortunately too well-behaved"],
      ["Sleeping Dogs", "Our dogs are always wide awake and barking"],
      ["Yakuza", "We absolutely cannot afford karaoke licenses"],
      ["Persona 5", "Style requires fashion sense we don't possess"],
      ["Fire Emblem", "Our emblems keep burning out unexpectedly"],
      ["Animal Crossing", "Tom Nook has better business sense than us"],
      ["Pokemon", "Catching 'em all requires catching at least one first"],
      ["Monster Hunter", "We are the monsters being hunted by deadlines"],
      ["Devil May Cry", "Our combos are just desperate button mashing"],
      ["Bayonetta", "Way too stylish, we only own cargo shorts"],
      ["NieR: Automata", "Existential crisis not included in our budget"],
      ["Kingdom Hearts", "Disney lawyers give us actual nightmares"],
      ["Chrono Trigger", "Time travel keeps breaking our version control"],
      ["EarthBound", "Our humor isn't nearly quirky enough"],
      ["Secret of Mana", "Our mana pool is just energy drinks"],
      ["Castlevania", "Whips are surprisingly expensive to animate"],
      ["Mega Man", "Our man is just regular-sized and tired"],
      ["Contra", "Up up down down is literally our entire skill set"],
      ["Double Dragon", "One dragon is already too many for us"],
      ["Ghosts 'n Goblins", "Our ghosts are just bedsheets with holes"],
      ["Battletoads", "Our toads can't even hop properly"],
      ["Adventure (Atari)", "Square protagonist is actually our skill level"],
      ["Pong", "Okay... we might actually be able to make this one"],
      ["Space Invaders", "Our invaders politely knock first"]
    ];

    // Excuses for why we haven't published a game yet
    const excuses = [
      "Stuck in prototype hell since 2024",
      "Too busy watching game dev tutorials",
      "Our lead developer discovered coffee breaks",
      "The code compiled once and we're afraid to touch it",
      "Waiting for the perfect game idea (any day now)",
      "Our artist is still learning to draw circles",
      "Scope creep ate our first seven projects",
      "We keep restarting in new game engines",
      "Someone said 'what if we add multiplayer' and everything collapsed",
      "Our project manager is also our only developer",
      "The backlog has become sentient and refuses to shrink",
      "We accidentally deleted the main branch. Twice.",
      "Currently debugging a bug that creates more bugs",
      "Our Trello board has achieved critical mass",
      "The intern shipped to production and we're still recovering",
      "Refactoring the refactored refactor",
      "Our game design document is longer than War and Peace",
      "Waiting for motivation to compile",
      "The build server is held together with hope and duct tape",
      "We pivoted so many times we're back at the original idea",
      "Our sprint planning meeting is in its third week",
      "Someone enabled dark mode and we can't find the code anymore",
      "The physics engine gained consciousness and quit",
      "Our vertical slice is more of a horizontal nap",
      "We keep adding 'one more feature' before launch",
      "The game is done but we can't agree on the title",
      "Our QA team (also us) keeps finding 'character-building' bugs",
      "We're waiting for the right alignment of stars and compilers",
      "Too many cooks, not enough actual cooking",
      "Our minimum viable product has maximum viable delays",
      "Someone mentioned 'blockchain integration' as a joke and management took notes",
      "The tutorial level has been in development for 18 months",
      "We scheduled the launch and then invented new procrastination methods",
      "Our roadmap needs its own roadmap",
      "Still recovering from the Great Merge Conflict of 2024",
      "The game works perfectly, except for the game part",
      "Our playtester (the developer's mom) gave harsh feedback",
      "We keep stopping to admire our own placeholder art",
      "The loading screen is done, everything else is TBD",
      "Our agile methodology became suspiciously waterfall",
      "We discovered Steam has other games and got distracted",
      "The main menu alone took six months",
      "Our deadline is a moving target (it moves away from us)",
      "We're 90% done, which means we're 50% done",
      "The release date is 'when it's ready' (never)",
      "Our code review process requires actual code",
      "Someone installed a new font and the whole UI broke",
      "We're still arguing about tabs vs spaces",
      "The game loop has become a game circle, then a game dot",
      "Our version control has commitment issues",
      "We keep getting sidetracked by cool shader effects",
      "The AI pathfinding found a path straight to the exit",
      "Our crunch time crunched us instead",
      "We're perfectionists with imperfect time management",
      "The tutorial is longer than the actual game",
      "We added a day/night cycle and lost three months",
      "Our marketing budget is $0 and falling",
      "Someone asked 'but what about accessibility' and we spiraled (rightfully) for months",
      "The only bug-free code is the code we haven't written",
      "Our game keeps turning into a different game",
      "We decided to 'polish' and vanished into the void",
      "The scope of 'small indie game' grew to AAA somehow",
      "Our stand-up meetings became sit-down-and-cry meetings",
      "We're feature complete except for the features",
      "The game is fun, we just need to add the game",
      "Our alpha has been alpha for so long it's basically ancient Greek",
      "We keep rewriting the engine from scratch 'for fun'",
      "Steam page is ready, game is optional apparently",
      "The tutorial tooltip explaining tutorials needs a tutorial",
      "We discovered imposter syndrome isn't just an Among Us thing",
      "Our development cycle is more of a development dot",
      "The 'final' build folder has 47 versions",
      "We spent six months on a feature we cut",
      "Someone said 'soft launch' and we heard 'soft couch'",
      "Our technical debt has its own credit rating",
      "The game is ready but our self-doubt isn't",
      "We keep watching GDC talks instead of making games",
      "Our prototype is prototyping more prototypes",
      "We're in a committed relationship with procrastination",
      "The settings menu has more content than the game",
      "We added mod support before we had a game to mod",
      "Our game idea evolved into an existential crisis",
      "Still optimizing code that runs once at startup",
      "We're waiting for a sign (the exit sign is right there)",
      "The pre-pre-pre-alpha is coming along nicely",
      "Our save system saves everything except our sanity",
      "We're 'almost done' (we've been almost done for two years)",
      "The game crashes less than our motivation",
      "Our dev blog has more content than our game",
      "We keep saying 'after this refactor' like it means something",
      "Someone discovered procedural generation and we lost a year",
      "The only consistent thing is our inconsistency",
      "Our burnout rate exceeds our build rate",
      "We pivoted to 'thoughtful development' (that's code for slow)",
      "Still debugging the debugger",
      "Our game has great vibes, shame about the gameplay",
      "We're one 'aha moment' away from starting over again",
      "The README is comprehensive, the game is not",
      "We got distracted making tools to make the game faster",
      "Coming Soonâ„¢ (trademark pending, like the game)"
    ];

    // Shuffle array
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    // NOT made by section
    const shuffledGames = shuffleArray(gamesNotMade);
    let currentGameIndex = 0;
    const quoteNotElement = document.getElementById('game-quote-not');
    const gameNameEl = quoteNotElement.querySelector('.game-name');
    const reasonEl = quoteNotElement.querySelector('.reason');

    function showNextGame() {
      quoteNotElement.classList.remove('visible');
      setTimeout(() => {
        const [game, reason] = shuffledGames[currentGameIndex];
        gameNameEl.textContent = game;
        reasonEl.textContent = reason;
        quoteNotElement.classList.add('visible');
        currentGameIndex = (currentGameIndex + 1) % shuffledGames.length;
      }, 500);
    }

    // Made by section (excuses)
    const shuffledExcuses = shuffleArray(excuses);
    let currentExcuseIndex = 0;
    const quoteMadeElement = document.getElementById('game-quote-made');
    const excuseEl = quoteMadeElement.querySelector('.excuse');

    function showNextExcuse() {
      quoteMadeElement.classList.remove('visible');
      setTimeout(() => {
        excuseEl.textContent = shuffledExcuses[currentExcuseIndex];
        quoteMadeElement.classList.add('visible');
        currentExcuseIndex = (currentExcuseIndex + 1) % shuffledExcuses.length;
      }, 500);
    }

    // Show first items immediately
    showNextGame();
    showNextExcuse();
    // Rotate every 7.5 seconds
    setInterval(showNextGame, 7500);
    setInterval(showNextExcuse, 7500);
  </script>

  <script>
    // 3D Bulls running around perimeter
    const canvas = document.getElementById('bull-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7);
    scene.add(directionalLight);

    // Bull colors matching logo
    const bodyColor = 0x8B4513;
    const hornColor = 0xFFFACD;
    const darkColor = 0x4a2106;

    // Audio context for grunt sounds
    let audioCtx = null;
    function playGrunt() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.setValueAtTime(80, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.15);
      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
      osc.type = 'sawtooth';
      osc.start();
      osc.stop(audioCtx.currentTime + 0.2);
    }

    // Leg references for animation
    function createBull() {
      const bull = new THREE.Group();
      const legs = [];

      const bodyMat = new THREE.MeshPhongMaterial({ color: bodyColor, shininess: 30 });
      const furMat = new THREE.MeshPhongMaterial({ color: 0x654321, shininess: 10 });
      const snoutMat = new THREE.MeshPhongMaterial({ color: 0xD2691E, shininess: 20 });
      const hornMat = new THREE.MeshPhongMaterial({ color: hornColor, shininess: 60 });
      const legMat = new THREE.MeshPhongMaterial({ color: darkColor, shininess: 20 });
      const eyeMat = new THREE.MeshPhongMaterial({ color: 0x220000, shininess: 100 });
      const noseMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a, shininess: 50 });

      // Body - elongated sphere
      const bodyGeo = new THREE.SphereGeometry(1, 16, 12);
      bodyGeo.scale(1.4, 0.8, 0.7);
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      bull.add(body);

      // Chest/shoulder hump
      const chestGeo = new THREE.SphereGeometry(0.6, 12, 10);
      const chest = new THREE.Mesh(chestGeo, bodyMat);
      chest.position.set(0.5, 0.4, 0);
      chest.scale.set(1, 1.1, 0.9);
      bull.add(chest);

      // Fur/mane around neck
      const maneGeo = new THREE.SphereGeometry(0.5, 10, 8);
      const mane = new THREE.Mesh(maneGeo, furMat);
      mane.position.set(0.9, 0.2, 0);
      mane.scale.set(0.8, 1, 1.2);
      bull.add(mane);

      // Head - sphere
      const headGeo = new THREE.SphereGeometry(0.5, 14, 12);
      const head = new THREE.Mesh(headGeo, bodyMat);
      head.position.set(1.3, 0.35, 0);
      head.scale.set(1, 0.9, 0.85);
      bull.add(head);

      // Snout - elongated sphere
      const snoutGeo = new THREE.SphereGeometry(0.3, 12, 10);
      snoutGeo.scale(1.2, 0.8, 1);
      const snout = new THREE.Mesh(snoutGeo, snoutMat);
      snout.position.set(1.7, 0.15, 0);
      bull.add(snout);

      // Nostrils
      const nostrilGeo = new THREE.SphereGeometry(0.06, 8, 6);
      [-0.1, 0.1].forEach(z => {
        const nostril = new THREE.Mesh(nostrilGeo, noseMat);
        nostril.position.set(1.95, 0.1, z);
        bull.add(nostril);
      });

      // Eyes
      const eyeGeo = new THREE.SphereGeometry(0.08, 10, 8);
      const eyeWhiteGeo = new THREE.SphereGeometry(0.12, 10, 8);
      const eyeWhiteMat = new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 100 });
      [-0.25, 0.25].forEach(z => {
        const eyeWhite = new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat);
        eyeWhite.position.set(1.5, 0.5, z);
        bull.add(eyeWhite);
        const eye = new THREE.Mesh(eyeGeo, eyeMat);
        eye.position.set(1.58, 0.5, z);
        bull.add(eye);
      });

      // Ears
      const earGeo = new THREE.ConeGeometry(0.15, 0.25, 8);
      [-0.35, 0.35].forEach(z => {
        const ear = new THREE.Mesh(earGeo, bodyMat);
        ear.position.set(1.1, 0.7, z);
        ear.rotation.x = z > 0 ? -0.5 : 0.5;
        ear.rotation.z = -0.3;
        bull.add(ear);
      });

      // Horns - curved using torus segments
      const hornGeo = new THREE.ConeGeometry(0.1, 0.8, 12);

      const leftHorn = new THREE.Mesh(hornGeo, hornMat);
      leftHorn.position.set(1.15, 0.85, 0.3);
      leftHorn.rotation.z = -0.6;
      leftHorn.rotation.x = -0.4;
      bull.add(leftHorn);

      const rightHorn = new THREE.Mesh(hornGeo, hornMat);
      rightHorn.position.set(1.15, 0.85, -0.3);
      rightHorn.rotation.z = -0.6;
      rightHorn.rotation.x = 0.4;
      bull.add(rightHorn);

      // Horn tips
      const tipGeo = new THREE.SphereGeometry(0.06, 8, 6);
      const tipMat = new THREE.MeshPhongMaterial({ color: 0xfffff0, shininess: 80 });
      const leftTip = new THREE.Mesh(tipGeo, tipMat);
      leftTip.position.set(0.85, 1.2, 0.5);
      bull.add(leftTip);
      const rightTip = new THREE.Mesh(tipGeo, tipMat);
      rightTip.position.set(0.85, 1.2, -0.5);
      bull.add(rightTip);

      // Legs - cylinders with joints
      const upperLegGeo = new THREE.CylinderGeometry(0.12, 0.1, 0.5, 10);
      const lowerLegGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.45, 10);
      const hoofGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.12, 10);
      const hoofMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a, shininess: 40 });

      const legPositions = [
        { x: 0.7, z: 0.3, phase: 0 },
        { x: 0.7, z: -0.3, phase: Math.PI },
        { x: -0.8, z: 0.3, phase: Math.PI },
        { x: -0.8, z: -0.3, phase: 0 }
      ];

      legPositions.forEach(pos => {
        const legPivot = new THREE.Group();
        legPivot.position.set(pos.x, -0.4, pos.z);

        const upperLeg = new THREE.Mesh(upperLegGeo, legMat);
        upperLeg.position.y = -0.25;
        legPivot.add(upperLeg);

        const lowerLeg = new THREE.Mesh(lowerLegGeo, legMat);
        lowerLeg.position.y = -0.55;
        legPivot.add(lowerLeg);

        const hoof = new THREE.Mesh(hoofGeo, hoofMat);
        hoof.position.y = -0.8;
        legPivot.add(hoof);

        legPivot.userData.phase = pos.phase;
        bull.add(legPivot);
        legs.push(legPivot);
      });

      // Tail - multiple segments
      const tailGroup = new THREE.Group();
      tailGroup.position.set(-1.3, 0.1, 0);
      for (let i = 0; i < 4; i++) {
        const segGeo = new THREE.CylinderGeometry(0.04 - i*0.008, 0.04 - (i+1)*0.008, 0.25, 8);
        const seg = new THREE.Mesh(segGeo, legMat);
        seg.position.set(-i * 0.2, -i * 0.1, 0);
        seg.rotation.z = 0.3 + i * 0.15;
        tailGroup.add(seg);
      }
      // Tail tuft
      const tuftGeo = new THREE.SphereGeometry(0.08, 8, 6);
      const tuft = new THREE.Mesh(tuftGeo, furMat);
      tuft.position.set(-0.7, -0.4, 0);
      tailGroup.add(tuft);
      bull.add(tailGroup);

      // Nose ring
      const ringGeo = new THREE.TorusGeometry(0.1, 0.025, 12, 20);
      const ringMat = new THREE.MeshPhongMaterial({ color: 0xC0C0C0, shininess: 100 });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.set(1.92, 0.02, 0);
      ring.rotation.y = Math.PI / 2;
      bull.add(ring);

      bull.scale.set(0.8, 0.8, 0.8);
      bull.userData.legs = legs;

      return bull;
    }

    // Create animated box (like in logo)
    function createBox() {
      const box = new THREE.Group();
      const flaps = [];

      const boxMat = new THREE.MeshPhongMaterial({ color: 0xD2691E, shininess: 30 });
      const boxLightMat = new THREE.MeshPhongMaterial({ color: 0xE8A030, shininess: 40 });
      const boxDarkMat = new THREE.MeshPhongMaterial({ color: 0xA0522D, shininess: 20 });
      const insideMat = new THREE.MeshPhongMaterial({ color: 0x8B4513, shininess: 10 });

      // Box base (bottom)
      const baseGeo = new THREE.BoxGeometry(1, 0.1, 1);
      const base = new THREE.Mesh(baseGeo, boxDarkMat);
      base.position.y = -0.45;
      box.add(base);

      // Box sides
      const sideGeo = new THREE.BoxGeometry(1, 0.8, 0.08);
      const frontSide = new THREE.Mesh(sideGeo, boxMat);
      frontSide.position.set(0, 0, 0.46);
      box.add(frontSide);

      const backSide = new THREE.Mesh(sideGeo, boxMat);
      backSide.position.set(0, 0, -0.46);
      box.add(backSide);

      const sideSideGeo = new THREE.BoxGeometry(0.08, 0.8, 1);
      const leftSide = new THREE.Mesh(sideSideGeo, boxLightMat);
      leftSide.position.set(-0.46, 0, 0);
      box.add(leftSide);

      const rightSide = new THREE.Mesh(sideSideGeo, boxDarkMat);
      rightSide.position.set(0.46, 0, 0);
      box.add(rightSide);

      // Inside darkness
      const insideGeo = new THREE.BoxGeometry(0.9, 0.7, 0.9);
      const inside = new THREE.Mesh(insideGeo, insideMat);
      inside.position.y = -0.05;
      box.add(inside);

      // Flaps (animated)
      const flapGeo = new THREE.BoxGeometry(0.9, 0.08, 0.4);
      const flapSideGeo = new THREE.BoxGeometry(0.4, 0.08, 0.9);

      // Front flap
      const frontFlapPivot = new THREE.Group();
      frontFlapPivot.position.set(0, 0.4, 0.46);
      const frontFlap = new THREE.Mesh(flapGeo, boxLightMat);
      frontFlap.position.z = 0.2;
      frontFlapPivot.add(frontFlap);
      box.add(frontFlapPivot);
      flaps.push({ pivot: frontFlapPivot, axis: 'x', dir: 1 });

      // Back flap
      const backFlapPivot = new THREE.Group();
      backFlapPivot.position.set(0, 0.4, -0.46);
      const backFlap = new THREE.Mesh(flapGeo, boxLightMat);
      backFlap.position.z = -0.2;
      backFlapPivot.add(backFlap);
      box.add(backFlapPivot);
      flaps.push({ pivot: backFlapPivot, axis: 'x', dir: -1 });

      // Left flap
      const leftFlapPivot = new THREE.Group();
      leftFlapPivot.position.set(-0.46, 0.4, 0);
      const leftFlap = new THREE.Mesh(flapSideGeo, boxMat);
      leftFlap.position.x = -0.2;
      leftFlapPivot.add(leftFlap);
      box.add(leftFlapPivot);
      flaps.push({ pivot: leftFlapPivot, axis: 'z', dir: -1 });

      // Right flap
      const rightFlapPivot = new THREE.Group();
      rightFlapPivot.position.set(0.46, 0.4, 0);
      const rightFlap = new THREE.Mesh(flapSideGeo, boxMat);
      rightFlap.position.x = 0.2;
      rightFlapPivot.add(rightFlap);
      box.add(rightFlapPivot);
      flaps.push({ pivot: rightFlapPivot, axis: 'z', dir: 1 });

      box.scale.set(0.6, 0.6, 0.6);
      box.userData.flaps = flaps;
      return box;
    }

    // Create 20 bulls with perimeter path data
    const bulls = [];
    const numBulls = 20;
    const margin = 3;

    for (let i = 0; i < numBulls; i++) {
      const bull = createBull();
      bull.userData = {
        ...bull.userData,
        progress: i / numBulls,
        speed: 0.0003 + Math.random() * 0.0002,
        bobOffset: Math.random() * Math.PI * 2,
        targetX: 0,
        targetY: 0,
        chasing: false,
        facingRight: true,
        lastGrunt: 0
      };
      scene.add(bull);
      bulls.push(bull);
    }

    // Create floating boxes in circular orbit around logo
    const boxes = [];
    const numBoxes = 8;
    const orbitRadius = 14;

    for (let i = 0; i < numBoxes; i++) {
      const box = createBox();
      const angle = (i / numBoxes) * Math.PI * 2;
      box.userData = {
        flaps: box.userData.flaps,
        floatOffset: Math.random() * Math.PI * 2,
        floatSpeed: 0.5 + Math.random() * 0.3,
        openPhase: Math.random() * Math.PI * 2,
        openSpeed: 0.3 + Math.random() * 0.2,
        orbitAngle: angle,
        orbitSpeed: 0.15 + Math.random() * 0.05,
        orbitRadius: orbitRadius + (Math.random() - 0.5) * 2
      };
      scene.add(box);
      boxes.push(box);
    }

    // Mouse tracking
    let mouseX = 0, mouseY = 0;
    let isHoveringTitle = false;

    const title = document.getElementById('title');
    title.addEventListener('mouseenter', () => { isHoveringTitle = true; });
    title.addEventListener('mouseleave', () => { isHoveringTitle = false; });

    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    function screenToWorld(sx, sy) {
      const aspect = window.innerWidth / window.innerHeight;
      const vFov = camera.fov * Math.PI / 180;
      const height = 2 * Math.tan(vFov / 2) * camera.position.z;
      const width = height * aspect;
      return {
        x: (sx / window.innerWidth - 0.5) * width,
        y: -(sy / window.innerHeight - 0.5) * height
      };
    }

    function getPerimeterPosition(progress, w, h) {
      const perimeter = 2 * w + 2 * h;
      const dist = progress * perimeter;

      if (dist < w) {
        return { x: -w/2 + dist, y: h/2, dir: 1 };
      } else if (dist < w + h) {
        return { x: w/2, y: h/2 - (dist - w), dir: 1 };
      } else if (dist < 2*w + h) {
        return { x: w/2 - (dist - w - h), y: -h/2, dir: -1 };
      } else {
        return { x: -w/2, y: -h/2 + (dist - 2*w - h), dir: -1 };
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      const aspect = window.innerWidth / window.innerHeight;
      const vFov = camera.fov * Math.PI / 180;
      const height = 2 * Math.tan(vFov / 2) * camera.position.z;
      const width = height * aspect;
      const time = Date.now() * 0.001;

      const mouseWorld = screenToWorld(mouseX, mouseY);

      bulls.forEach(bull => {
        const ud = bull.userData;
        let targetX, targetY, movingRight;

        if (isHoveringTitle) {
          // Chase mouse
          targetX = mouseWorld.x;
          targetY = mouseWorld.y;
          ud.chasing = true;
        } else {
          // Return to perimeter
          ud.progress += ud.speed;
          if (ud.progress > 1) ud.progress -= 1;
          const pos = getPerimeterPosition(ud.progress, width - margin * 2, height - margin * 2);
          targetX = pos.x;
          targetY = pos.y;
          movingRight = pos.dir > 0;
          ud.chasing = false;
        }

        // Smooth movement toward target
        const dx = targetX - bull.position.x;
        const dy = targetY - bull.position.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const moveSpeed = ud.chasing ? 0.015 : 0.08;

        bull.position.x += dx * moveSpeed;
        bull.position.y += dy * moveSpeed;

        // Determine facing direction based on horizontal movement
        if (Math.abs(dx) > 0.01) {
          ud.facingRight = dx > 0;
        }

        // Flip bull horizontally using scale (keeps side view always facing camera)
        // Bull is built along X axis, so we flip scale.x to change direction
        const targetScaleX = ud.facingRight ? 0.8 : -0.8;
        bull.scale.x += (targetScaleX - bull.scale.x) * 0.15;

        // Keep rotation.y at 0 so side always faces camera
        bull.rotation.y = 0;

        // Leg animation - galloping motion
        const legSpeed = ud.chasing ? 15 : 8;
        const legAmplitude = ud.chasing ? 0.6 : 0.3;
        ud.legs.forEach(leg => {
          leg.rotation.x = Math.sin(time * legSpeed + leg.userData.phase + ud.bobOffset) * legAmplitude;
        });

        // Body bob
        bull.position.y += Math.sin(time * (ud.chasing ? 12 : 6) + ud.bobOffset) * (ud.chasing ? 0.1 : 0.05);

        // Check if reached mouse (grunt)
        if (ud.chasing && dist < 2) {
          const now = Date.now();
          if (now - ud.lastGrunt > 500) {
            playGrunt();
            ud.lastGrunt = now;
          }
        }
      });

      // Animate boxes - orbit around logo center
      // Logo is centered on screen, slightly above middle
      const orbitCenterY = 2;

      boxes.forEach(box => {
        const ud = box.userData;

        // Update orbit angle
        ud.orbitAngle += ud.orbitSpeed * 0.01;

        // Calculate position on circular orbit
        box.position.x = Math.cos(ud.orbitAngle) * ud.orbitRadius;
        box.position.y = orbitCenterY + Math.sin(ud.orbitAngle) * ud.orbitRadius * 0.5; // Elliptical, flatter
        box.position.z = Math.sin(ud.orbitAngle) * 3 - 5; // Depth variation

        // Add gentle floating bob
        box.position.y += Math.sin(time * ud.floatSpeed + ud.floatOffset) * 0.3;

        // Rotate box to face outward from center + spin
        box.rotation.y = -ud.orbitAngle + Math.PI + time * 0.5;
        box.rotation.x = Math.sin(time * 0.5 + ud.floatOffset) * 0.15;
        box.rotation.z = Math.cos(time * 0.3 + ud.floatOffset) * 0.1;

        // Animate flaps open/closed
        const openAmount = (Math.sin(time * ud.openSpeed + ud.openPhase) + 1) / 2; // 0 to 1
        const flapAngle = openAmount * Math.PI * 0.4; // 0 to ~72 degrees

        ud.flaps.forEach(flap => {
          if (flap.axis === 'x') {
            flap.pivot.rotation.x = flapAngle * flap.dir;
          } else {
            flap.pivot.rotation.z = flapAngle * flap.dir;
          }
        });
      });

      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
